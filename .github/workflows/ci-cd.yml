#CI/CD:

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allows the workflow to be triggered manually from the GitHub UI

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}  # AWS region from secrets
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}  # AWS access key ID from secrets
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}  # AWS secret access key from secrets
  PROJECT_NAME: ${{ secrets.PROJECT_NAME }}  # Project name as an environment variable
  SPRING_BOOT_APP_NAME: ${{ secrets.SPRING_BOOT_APP_NAME }}  # Spring Boot app name as an environment variable
  CONTAINER_PORT: ${{ secrets.CONTAINER_PORT }} # Port from secrets
  IMAGE_TAG: latest #${{ github.sha }}  # Use GitHub SHA as the tag for the image
  EKS_CLUSTER_NAME: ${{ secrets.PROJECT_NAME }}-eks-cluster
  ECR_REPOSITORY_URL: "761018885188.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ secrets.SPRING_BOOT_APP_NAME }}"  # ECR repository URL

jobs:
  app-build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up JDK 18
        uses: actions/setup-java@v3
        with:
          java-version: 18
          distribution: 'adopt'

      - name: Cache Maven packages
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Build and test with Maven
        run: mvn --batch-mode --update-snapshots --no-transfer-progress clean package

      - name: Upload JAR file
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: target/*.jar

  image-build:
    needs: app-build
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: 17
          distribution: 'adopt'

      - name: Download JAR file
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      - name: Install AWS CLI
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install --update
          aws configure set aws_access_key_id ${{ env.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws configure set default.region ${{ env.AWS_REGION }}

      - name: Create repo in ECR (If it doesn't exist)
        run: |
          aws ecr describe-repositories --repository-names ${{ env.SPRING_BOOT_APP_NAME }} --region "${{ env.AWS_REGION }}" || aws ecr create-repository --repository-name ${{ env.SPRING_BOOT_APP_NAME }} --region "${{ env.AWS_REGION }}"

      - name: Build Docker image
        run: |
          docker build -t ${{ env.ECR_REPOSITORY_URL }}:${{ env.IMAGE_TAG }} .

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REPOSITORY_URL }}

      - name: Tag Docker image
        run: |
          docker tag ${{ env.ECR_REPOSITORY_URL }}:${{ env.IMAGE_TAG }} 761018885188.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.SPRING_BOOT_APP_NAME }}:latest

      - name: Push Docker image
        run: |
          docker push ${{ env.ECR_REPOSITORY_URL }}:${{ env.IMAGE_TAG }}

  infra-build:
    needs: image-build
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials for Terraform
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure Terraform Directory Exists
        run: mkdir -p ./terraform  # Create the 'terraform' directory if it doesn't exist

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.5.0"  # Specify Terraform version to use

      - name: Check if terraform plan exists
        id: plan_check
        run: |
          if [ -f ./terraform/${{ env.EKS_CLUSTER_NAME }}-plan.out ]; then
            echo "Terraform plan exists."
            echo "PLAN_EXISTS=true" >> $GITHUB_ENV
          else
            echo "Terraform plan does not exist."
            echo "PLAN_EXISTS=false" >> $GITHUB_ENV
          fi

      - name: Generate and Apply Terraform Plan (if no plan exists)
        if: env.PLAN_EXISTS == 'false'
        run: |
          terraform -chdir=./terraform plan -out="./terraform/${{ env.EKS_CLUSTER_NAME }}-plan.out" # Generate the plan and save it to the 'terraform' directory
          terraform -chdir=./terraform apply -auto-approve "./terraform/${{ env.EKS_CLUSTER_NAME }}-plan.out"  # Apply the plan

      - name: Apply Terraform Plan (if plan exists)
        if: env.PLAN_EXISTS == 'true'
        run: |
          terraform -chdir=./terraform apply -auto-approve "./terraform/${{ env.EKS_CLUSTER_NAME }}-plan.out"  # Apply the existing plan


  app-deploy:
    needs: infra-build
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Deploy to EKS
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
          mkdir -p k8s
          export ECR_REPOSITORY_URL="${{ env.ECR_REPOSITORY_URL }}:${{ env.IMAGE_TAG }}"
          envsubst < k8s-deployment.yaml > k8s/k8s-deployment.yaml
          echo "resources:" > k8s/kustomization.yaml
          echo "- k8s-deployment.yaml" >> k8s/kustomization.yaml
          kubectl kustomize k8s | kubectl apply -f - --force
